{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>This is just a placeholder file for the webpage re-direct. All the content for this section is actually in the <code>introduction.md</code> file.</p>"},{"location":"contribute/","title":"Contribute: Make an Augmentation!","text":"<p>Spot an improvement opportunity? Feel free to contribute to our open-source design and documentation. </p>"},{"location":"contribute/#improve-our-documentation","title":"Improve our Documentation","text":"<p>All of this documentation can be modified by you! Please help us make it better.</p> <ul> <li>These pages are contained in the <code>docs</code> folder of the SparkFun Optical Tracking Odometry Sensor - PAA5160E1 (Qwiic) repository.</li> </ul>"},{"location":"contribute/#submit-a-correction","title":"Submit a Correction","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your corrections or improvements to the markdown file.</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvements to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"contribute/#improve-our-hardware-design","title":"Improve our Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li> <p>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun Optical Tracking Odometry Sensor - PAA5160E1 (Qwiic) repository.</p> </li> <li> <p>With a GitHub account, fork this repository.</p> </li> <li>Add your design augmentation(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ol> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvement(s) to verify that they are within our board design standards and meet our product design requirements.</li> <li> <p>If approved, we will flag these changes for our next board revision. Congrats! \ud83c\udf7b</p> <p>Info</p> <p>Even if your suggestion is accepted, these changes may not be immediately available for purchase. We may have to cycle through our current product inventory first.</p> </li> </ol> </li> </ul>"},{"location":"contribute/#contributors","title":"Contributors","text":"<p>Let's provide some recognition to the contributors for this project!</p> <p> </p>"},{"location":"examples/","title":"Arduino Examples","text":"<p>Attention</p> <p>All of the examples require the user to enter a key into the serial monitor before the example starts, which triggers the IMU calibration. </p> <p>Attention</p> <p>The IMU on the Optical Tracking Odometry Sensor includes a gyroscope and accelerometer, which could have an offset. The OTOS performs a quick calibration when it powers up, but it is recommended to perform a more thorough calibration at the start of all your programs. </p>"},{"location":"examples/#example-1-basic-readings","title":"Example 1: Basic Readings","text":"<p>This first example just does some basic measurements to make sure everything is hooked up correctly. To find Example 1, go to File &gt; Examples &gt; SparkFun Qwiic OTOS &gt; Example1_BasicReadings:</p> <p></p> <p>Finding Example 1</p> <p>Alternatively, you can expand the link below and copy and paste the code into a shiny new Arduino sketch: </p> Example 1 Arduino Code <pre><code>/*\n    SPDX-License-Identifier: MIT\n\n    Copyright (c) 2024 SparkFun Electronics\n*/\n\n/*******************************************************************************\n    Example 1 - Basic Readings\n\n    This example demonstrates how to read the position and heading from the\n    SparkFun Qwiic Optical Tracking Odometry Sensor (OTOS).\n\n    This example should be used to verify that the OTOS is connected and\n    functioning correctly. It will just print the position and heading tracked\n    by the OTOS to the serial monitor. It is recommended that you check out the\n    other examples before using the OTOS in your own project.\n*******************************************************************************/\n\n#include \"SparkFun_Qwiic_OTOS_Arduino_Library.h\"\n#include \"Wire.h\"\n\n// Create an Optical Tracking Odometry Sensor object\nQwiicOTOS myOtos;\n\nvoid setup()\n{\n    // Start serial\n    Serial.begin(115200);\n    Serial.println(\"Qwiic OTOS Example 1 - Basic Readings\");\n\n    Wire.begin();\n\n    // Attempt to begin the sensor\n    while (myOtos.begin() == false)\n    {\n        Serial.println(\"OTOS not connected, check your wiring and I2C address!\");\n        delay(1000);\n    }\n\n    Serial.println(\"OTOS connected!\");\n\n    Serial.println(\"Ensure the OTOS is flat and stationary, then enter any key to calibrate the IMU\");\n\n    // Clear the serial buffer\n    while (Serial.available())\n        Serial.read();\n    // Wait for user input\n    while (!Serial.available())\n        ;\n\n    Serial.println(\"Calibrating IMU...\");\n\n    // Calibrate the IMU, which removes the accelerometer and gyroscope offsets\n    myOtos.calibrateImu();\n\n    // Reset the tracking algorithm - this resets the position to the origin,\n    // but can also be used to recover from some rare tracking errors\n    myOtos.resetTracking();\n}\n\nvoid loop()\n{\n    // Get the latest position, which includes the x and y coordinates, plus the\n    // heading angle\n    sfe_otos_pose2d_t myPosition;\n    myOtos.getPosition(myPosition);\n\n    // Print measurement\n    Serial.println();\n    Serial.println(\"Position:\");\n    Serial.print(\"X (Inches): \");\n    Serial.println(myPosition.x);\n    Serial.print(\"Y (Inches): \");\n    Serial.println(myPosition.y);\n    Serial.print(\"Heading (Degrees): \");\n    Serial.println(myPosition.h);\n\n    // Wait a bit so we don't spam the serial port\n    delay(500);\n\n    // Alternatively, you can comment out the print and delay code above, and\n    // instead use the following code to rapidly refresh the data\n    // Serial.print(myPosition.x);\n    // Serial.print(\"\\t\");\n    // Serial.print(myPosition.y);\n    // Serial.print(\"\\t\");\n    // Serial.println(myPosition.h);\n    // delay(10);\n}\n</code></pre> <p>Make sure you've selected the correct board and port in the Tools menu and then hit the upload button. Once the code has finished uploading, go ahead and open a Serial Monitor. You should see something similar to the following.  </p> <p></p> <p>Example 1 Output</p> <p>Move the sensor around to see how the coordinates change!</p>"},{"location":"examples/#example-2-setunits","title":"Example 2: SetUnits","text":"<p>This example sets the desired units for linear and angular measurements. Can be either meters or inches for linear, and radians or degrees for angular. If not set, the default is inches and degrees. Note that this setting is not stored in the sensor, it's part of the library, so you need to set at the start of all your programs.</p> <p>To find Example 2, go to File &gt; Examples &gt; SparkFun Qwiic OTOS &gt; Example2_SetUnits:</p> <p></p> <p>Finding Example 2</p> <p>Alternatively, you can expand the link below and copy and paste the code into a shiny new Arduino sketch: </p> Example 2 Arduino Code <pre><code>/*\n    SPDX-License-Identifier: MIT\n\n    Copyright (c) 2024 SparkFun Electronics\n*/\n\n/*******************************************************************************\n    Example 2 - Set Units\n\n    This example demonstrates how to change the units of the SparkFun Qwiic\n    Optical Tracking Odometry Sensor (OTOS).\n\n    The OTOS library defaults to inches and degrees, but you can change the\n    units to suit the needs of your project.\n*******************************************************************************/\n\n#include \"SparkFun_Qwiic_OTOS_Arduino_Library.h\"\n#include \"Wire.h\"\n\n// Create an Optical Tracking Odometry Sensor object\nQwiicOTOS myOtos;\n\nvoid setup()\n{\n    // Start serial\n    Serial.begin(115200);\n    Serial.println(\"Qwiic OTOS Example 2 - Set Units\");\n\n    Wire.begin();\n\n    // Attempt to begin the sensor\n    while (myOtos.begin() == false)\n    {\n        Serial.println(\"OTOS not connected, check your wiring and I2C address!\");\n        delay(1000);\n    }\n\n    Serial.println(\"OTOS connected!\");\n\n    Serial.println(\"Ensure the OTOS is flat and stationary, then enter any key to calibrate the IMU\");\n\n    // Clear the serial buffer\n    while (Serial.available())\n        Serial.read();\n    // Wait for user input\n    while (!Serial.available())\n        ;\n\n    Serial.println(\"Calibrating IMU...\");\n\n    // Calibrate the IMU, which removes the accelerometer and gyroscope offsets\n    myOtos.calibrateImu();\n\n    // Set the desired units for linear and angular measurements. Can be either\n    // meters or inches for linear, and radians or degrees for angular. If not\n    // set, the default is inches and degrees. Note that this setting is not\n    // stored in the sensor, it's part of the library, so you need to set at the\n    // start of all your programs.\n    myOtos.setLinearUnit(kSfeOtosLinearUnitMeters);\n    // myOtos.setLinearUnit(kSfeOtosLinearUnitInches);\n    myOtos.setAngularUnit(kSfeOtosAngularUnitRadians);\n    // myOtos.setAngularUnit(kSfeOtosAngularUnitDegrees);\n\n    // Reset the tracking algorithm - this resets the position to the origin,\n    // but can also be used to recover from some rare tracking errors\n    myOtos.resetTracking();\n}\n\nvoid loop()\n{\n    // Get the latest position, which includes the x and y coordinates, plus the\n    // heading angle\n    sfe_otos_pose2d_t myPosition;\n    myOtos.getPosition(myPosition);\n\n    // Print measurement\n    Serial.println();\n    Serial.println(\"Position:\");\n    Serial.print(\"X (Meters): \");\n    Serial.println(myPosition.x, 4);\n    Serial.print(\"Y (Meters): \");\n    Serial.println(myPosition.y, 4);\n    Serial.print(\"Heading (Radians): \");\n    Serial.println(myPosition.h, 4);\n\n    // Wait a bit so we don't spam the serial port\n    delay(500);\n}\n</code></pre> <p>Notice the following code snippet - this is the section of code that allows you to choose your units: </p> <p></p> <p>Example 2 Code To Change Units </p> <p>Make sure you've selected the correct board and port in the Tools menu and then hit the upload button. Once the code has finished uploading, go ahead and open a Serial Monitor. You should see something similar to the following.  </p> <p></p> <p>Example 2 Output</p>"},{"location":"examples/#example-3-calibration","title":"Example 3: Calibration","text":"<p>Warning</p> <p>As of firmware version 1.0, these calibration values will be lost after a power cycle, so you will need to set them each time you power up the sensor.</p> <p>The data from the OTOS will likely have minor scaling errors that can be calibrated out. This is especially important for the angular scalar, because an incorrect angle measurement causes the linear measurements to be rotated by the wrong angle in the firmware, which can lead to very inaccurate tracking.</p> <p>To find Example 3, go to File &gt; Examples &gt; SparkFun Qwiic OTOS &gt; Example3_Calibration:</p> <p></p> <p>Finding Example 3</p> <p>Alternatively, you can expand the link below and copy and paste the code into a shiny new Arduino sketch: </p> Example 3 Arduino Code <pre><code>/*\n    SPDX-License-Identifier: MIT\n\n    Copyright (c) 2024 SparkFun Electronics\n*/\n\n/*******************************************************************************\n    Example 3 - Calibration\n\n    This example demonstrates how to calibrate the SparkFun Qwiic Optical\n    Tracking Odometry Sensor (OTOS).\n\n    This example should be used to calibrate the linear and angular scalars of\n    the OTOS to get the most accurate tracking performance. The linear scalar\n    can be used to compensate for scaling issues with the x and y measurements,\n    while the angular scalar can be used to compensate for scaling issues with\n    the heading measurement. Note that if the heading measurement is off, that\n    can also cause the x and y measurements to be off, so it's recommended to\n    calibrate the angular scalar first.\n*******************************************************************************/\n\n#include \"SparkFun_Qwiic_OTOS_Arduino_Library.h\"\n#include \"Wire.h\"\n\n// Create an Optical Tracking Odometry Sensor object\nQwiicOTOS myOtos;\n\nvoid setup()\n{\n    // Start serial\n    Serial.begin(115200);\n    Serial.println(\"Qwiic OTOS Example 3 - Calibration\");\n\n    Wire.begin();\n\n    // Attempt to begin the sensor\n    while (myOtos.begin() == false)\n    {\n        Serial.println(\"OTOS not connected, check your wiring and I2C address!\");\n        delay(1000);\n    }\n\n    Serial.println(\"OTOS connected!\");\n\n    Serial.println(\"Ensure the OTOS is flat and stationary, then enter any key to calibrate the IMU\");\n\n    // Clear the serial buffer\n    while (Serial.available())\n        Serial.read();\n    // Wait for user input\n    while (!Serial.available())\n        ;\n\n    Serial.println(\"Calibrating IMU...\");\n\n    // The IMU on the OTOS includes a gyroscope and accelerometer, which could\n    // have an offset. Note that as of firmware version 1.0, the calibration\n    // will be lost after a power cycle; the OTOS performs a quick calibration\n    // when it powers up, but it is recommended to perform a more thorough\n    // calibration at the start of all your programs. Note that the sensor must\n    // be completely stationary and flat during calibration! When calling\n    // calibrateImu(), you can specify the number of samples to take and whether\n    // to wait until the calibration is complete. If no parameters are provided,\n    // it will take 255 samples and wait until done; each sample takes about\n    // 2.4ms, so about 612ms total\n    myOtos.calibrateImu();\n\n    // Alternatively, you can specify the number of samples and whether to wait\n    // until it's done. If you don't want to wait, you can asynchronously check\n    // how many samples remain with the code below. Once zero samples remain,\n    // the calibration is done!\n    // myOtos.calibrateImu(255, false);\n    // bool done = false;\n    // while(done == false)\n    // {\n    //     // Check how many samples remain\n    //     uint8_t samplesRemaining;\n    //     myOtos.getImuCalibrationProgress(samplesRemaining);\n\n    //     // If 0 samples remain, the calibration is done\n    //     if(samplesRemaining == 0)\n    //         done = true;\n    // }\n\n    // Here we can set the linear and angular scalars, which can compensate for\n    // scaling issues with the sensor measurements. Note that as of firmware\n    // version 1.0, these values will be lost after a power cycle, so you will\n    // need to set them each time you power up the sensor. They can be any value\n    // from 0.872 to 1.127 in increments of 0.001 (0.1%). It is recommended to\n    // first set both scalars to 1.0, then calibrate the angular scalar, then\n    // the linear scalar. To calibrate the angular scalar, spin the robot by\n    // multiple rotations (eg. 10) to get a precise error, then set the scalar\n    // to the inverse of the error. Remember that the angle wraps from -180 to\n    // 180 degrees, so for example, if after 10 rotations counterclockwise\n    // (positive rotation), the sensor reports -15 degrees, the required scalar\n    // would be 3600/3585 = 1.004. To calibrate the linear scalar, move the\n    // robot a known distance and measure the error; do this multiple times at\n    // multiple speeds to get an average, then set the linear scalar to the\n    // inverse of the error. For example, if you move the robot 100 inches and\n    // the sensor reports 103 inches, set the linear scalar to 100/103 = 0.971\n    myOtos.setLinearScalar(1.0);\n    myOtos.setAngularScalar(1.0);\n\n    // Reset the tracking algorithm - this resets the position to the origin,\n    // but can also be used to recover from some rare tracking errors\n    myOtos.resetTracking();\n}\n\nvoid loop()\n{\n    // Get the latest position, which includes the x and y coordinates, plus the\n    // heading angle\n    sfe_otos_pose2d_t myPosition;\n    myOtos.getPosition(myPosition);\n\n    // Print measurement\n    Serial.println();\n    Serial.println(\"Position:\");\n    Serial.print(\"X (Inches): \");\n    Serial.println(myPosition.x);\n    Serial.print(\"Y (Inches): \");\n    Serial.println(myPosition.y);\n    Serial.print(\"Heading (Degrees): \");\n    Serial.println(myPosition.h);\n\n    // Wait a bit so we don't spam the serial port\n    delay(500);\n\n}\n</code></pre> <p>Make sure you've selected the correct board and port in the Tools menu and then hit the upload button. Once the code has finished uploading, go ahead and open a Serial Monitor.</p> <p>Calibrating your bot requires you to move it around a bit. First, set both scalars to 1.0, then calibrate the angular scalar, then the linear scalar. </p> <p>To calibrate the angular scalar, spin the robot by multiple rotations (eg. 10) to get a precise error, then set the scalar to the inverse of the error. Remember that the angle wraps from -180 to 180 degrees, so for example, if after 10 rotations counterclockwise(positive rotation), the sensor reports -15 degrees, the required scalar would be 3600/3585 = 1.004. </p> <p></p> <p>Rotating the Optical Tracking Odometry Sensor</p> <p>To calibrate the linear scalar, move the robot a known distance and measure the error; do this multiple times at multiple speeds to get an average, then set the linear scalar to the inverse of the error. For example, if you move the robot 100 inches and the sensor reports 103 inches, set the linear scalar to 100/103 = 0.971. </p> <p></p> <p>Moving the Optical Tracking Odometry Sensor</p>"},{"location":"examples/#example-4-setoffsetandposition","title":"Example 4: SetOffsetAndPosition","text":"<p>This example shows how to set the offset for the sensor relative to the center of the robot. The units default to inches and degrees, but if you want to use different units, make sure you specify them before setting the offset. Without setting the offset, the OTOS will report the coordinates of itself. If the offset is set, the OTOS will instead report the coordinates of the center of your robot.</p> <p>Note that the OTOS typically starts tracking from the origin, but if your robot starts at some other location, or you have another source of location information from another sensor that's more accurate, you can send the current location to the OTOS and it will continue tracking from there.</p> <p>Warning</p> <p>As of firmware version 1.0, these values will be lost after a power cycle, so you will need to set them each time you power up the sensor. </p> <p>To find Example 4, go to File &gt; Examples &gt; SparkFun Qwiic OTOS &gt; Example4_SetOffsetAndPosition:</p> <p></p> <p>Finding Example 4</p> <p>Alternatively, you can expand the link below and copy and paste the code into a shiny new Arduino sketch: </p> Example 4 Arduino Code <pre><code>/*\n    SPDX-License-Identifier: MIT\n\n    Copyright (c) 2024 SparkFun Electronics\n*/\n\n/*******************************************************************************\n    Example 4 - Set Offset and Position\n\n    This example demonstrates how to set the offset and position of the SparkFun\n    Qwiic Optical Tracking Odometry Sensor (OTOS).\n\n    If your OTOS is mounted to a robot and is not centered, you can specify the\n    offset for the sensor relative to the center of the robot; rather than\n    returning the position of the sensor, the OTOS will calculate and return the\n    position of the robot's center. If you know where your robot is located,\n    such as the starting location or from another sensor, you can send that\n    position to the OTOS and it will continue to track from there.\n*******************************************************************************/\n\n#include \"SparkFun_Qwiic_OTOS_Arduino_Library.h\"\n#include \"Wire.h\"\n\n// Create an Optical Tracking Odometry Sensor object\nQwiicOTOS myOtos;\n\nvoid setup()\n{\n    // Start serial\n    Serial.begin(115200);\n    Serial.println(\"Qwiic OTOS Example 4 - Set Offset and Position\");\n\n    Wire.begin();\n\n    // Attempt to begin the sensor\n    while (myOtos.begin() == false)\n    {\n        Serial.println(\"OTOS not connected, check your wiring and I2C address!\");\n        delay(1000);\n    }\n\n    Serial.println(\"OTOS connected!\");\n\n    Serial.println(\"Ensure the OTOS is flat and stationary, then enter any key to calibrate the IMU\");\n\n    // Clear the serial buffer\n    while (Serial.available())\n        Serial.read();\n    // Wait for user input\n    while (!Serial.available())\n        ;\n\n    Serial.println(\"Calibrating IMU...\");\n\n    // Calibrate the IMU, which removes the accelerometer and gyroscope offsets\n    myOtos.calibrateImu();\n\n    // Assuming you've mounted your sensor to a robot and it's not centered,\n    // you can specify the offset for the sensor relative to the center of the\n    // robot. The units default to inches and degrees, but if you want to use\n    // different units, specify them before setting the offset! Note that as of\n    // firmware version 1.0, these values will be lost after a power cycle, so\n    // you will need to set them each time you power up the sensor. For example, if\n    // the sensor is mounted 5 inches to the left (negative X) and 10 inches\n    // forward (positive Y) of the center of the robot, and mounted 90 degrees\n    // clockwise (negative rotation) from the robot's orientation, the offset\n    // would be {-5, 10, -90}. These can be any value, even the angle can be\n    // tweaked slightly to compensate for imperfect mounting (eg. 1.3 degrees).\n    sfe_otos_pose2d_t offset = {-5, 10, -90};\n    myOtos.setOffset(offset);\n\n    // Reset the tracking algorithm - this resets the position to the origin,\n    // but can also be used to recover from some rare tracking errors\n    myOtos.resetTracking();\n\n    // After resetting the tracking, the OTOS will report that the robot is at\n    // the origin. If your robot does not start at the origin, or you have\n    // another source of location information (eg. vision odometry), you can set\n    // the OTOS location to match and it will continue to track from there.\n    sfe_otos_pose2d_t currentPosition = {0, 0, 0};\n    myOtos.setPosition(currentPosition);\n}\n\nvoid loop()\n{\n    // Get the latest position, which includes the x and y coordinates, plus the\n    // heading angle\n    sfe_otos_pose2d_t myPosition;\n    myOtos.getPosition(myPosition);\n\n    // Print measurement\n    Serial.println();\n    Serial.println(\"Position:\");\n    Serial.print(\"X (Inches): \");\n    Serial.println(myPosition.x);\n    Serial.print(\"Y (Inches): \");\n    Serial.println(myPosition.y);\n    Serial.print(\"Heading (Degrees): \");\n    Serial.println(myPosition.h);\n\n    // Wait a bit so we don't spam the serial port\n    delay(500);\n\n}\n</code></pre> <p>If the sensor is mounted 5 inches to the left (negative X) and 10 inches forward (positive Y) of the center of the robot, and mounted 90 degrees clockwise (negative rotation) from the robot's orientation, the offset would be {-5, 10, -90}. These can be any value, even the angle can be tweaked slightly to compensate for imperfect mounting (eg. 1.3 degrees).</p> <p></p> <p>The X, Y, and Angular Offset of the Optical Tracking Sensor</p> <p>These four examples cover the basics - there are more examples to explore in the library! </p>"},{"location":"examples_ftc/","title":"Examples ftc","text":"<p>Attention</p> <p>Please ensure you have done the Software Setup before attempting to run the example! You need to have at least version v9.2 of the SDK running on the Control Hub, and add the sensor to your Hardware Config.</p> <p>Unlike our Arduino and Python libraries that include several examples, there is only a single but comprehensive example for FTC. This sample OpMode is available in Blocks, OnBot Java, and Android Studio; setup instructions are avaiable for each, but running the sample is the same.</p>"},{"location":"examples_ftc/#blocks","title":"Blocks","text":"<p>Create a new OpMode based on the sample called <code>SensorSparkFunOTOS</code>.</p> <p>TODO</p>"},{"location":"examples_ftc/#onbot-java","title":"OnBot Java","text":"<p>Create a new OpMode based on the sample called <code>SensorSparkFunOTOS</code>.</p> <p>TODO</p>"},{"location":"examples_ftc/#android-studio","title":"Android Studio","text":"<p>Navigate to the sample OpModes under FtcRobotController -&gt; java -&gt; <code>org.firstinspires.ftc.robotcontroller.external.samples</code> -&gt; <code>SensorSparkFunOTOS</code>. Make a copy of this file in the TeamCode folder along with the rest of your code.</p> <p>Attention</p> <p>It is strongly recommended that you do not modify the sample OpModes within the FtcRobotController sample folder! Always make a copy so you have clean examples to work with!</p> <p>After making a copy, comment out or delete the <code>@Disabled</code> to enable the OpMode. Then upload the code to the robot.</p> <p></p>"},{"location":"examples_ftc/#run-the-example","title":"Run the Example","text":"<p>On the Driver Station, select the TeleOp dropdown menu, and you should see the <code>Sensor: SparkFun OTOS</code> sample OpMode; select it.</p> <p>When you press the <code>INIT</code> button, the sensor will initialize, the IMU will be calibrated, and the tracking algorithm will be reset. The telemetry on the driver station will display the version numbers read from the device.</p> <p>When you press the <code>Start</code> button, the telemetry will display the (x,y) coordinates and heading angle of the robot, as measure by the sensor. If you have gamepad #1 connected, you can press Y (triangle) to reset the tracking, or press X (square) to re-calibrate the IMU.</p> <p></p>"},{"location":"examples_xrp/","title":"Python Examples","text":"<p>Attention</p> <p>These instructions are written for the XRP using the XRPCode IDE. However the setup process is very similar for MicroPython and CircuitPython on any other board, so you should be able to follow along with these instructions using your IDE of choice!</p>"},{"location":"examples_xrp/#download-examples","title":"Download Examples","text":"<p>First, go to the Qwiic_OTOS_Py repository, open the <code>examples</code> folder, and download the example files you want to run.</p> <p>Connect your XRP to your computer over USB, navigate to the XRPCode editor, and connect to your XRP. For usage information, see the XRPCode User Guide.</p> <p>Upload the example files into the root directory (<code>/</code>), or directory of your choice, on the XRP. Begin by finding the <code>Upload to XRP</code> option:</p> <p></p> <p><code>Upload to XRP</code> option in the File Menu</p> <p>Select the files to upload: </p> <p></p> <p>Selecting the Files to Upload</p> <p>Select the root directory (<code>/</code>), or directory of your choice, on the XRP:</p> <p></p> <p>Select the root directory (<code>/</code>)</p> <p>Click the OK button and wait for the files to upload and save:</p> <p></p> <p>Updating</p> <p>You should then see the examples in the Filesystem panel on the left:</p> <p></p> <p>Finding the examples in the FileSystem</p>"},{"location":"examples_xrp/#example-1-basic-readings","title":"Example 1: Basic Readings","text":"<p>This first example just does some basic measurements to make sure everything is hooked up correctly. Assuming you uploaded this example in the procedure above, double-click <code>qwiic_otos_ex1_basic_readings.py</code> in the Filesystem panel on the left:</p> <p></p> <p><code>qwiic_otos_ex1_basic_readings.py</code> XRP File Location</p> <p>Alternatively, you can expand the link below and copy and paste the code into a shiny new file:</p> Example 1 Python Code <pre><code>#!/usr/bin/env python\n#-------------------------------------------------------------------------------\n# qwiic_otos_ex1_basic_readings.py\n#\n# This example demonstrates how to read the position and heading from the\n# SparkFun Qwiic Optical Tracking Odometry Sensor (OTOS).\n#\n# This example should be used to verify that the OTOS is connected and\n# functioning correctly. It will just print the position and heading tracked\n# by the OTOS to the serial monitor. It is recommended that you check out the\n# other examples before using the OTOS in your own project.\n#-------------------------------------------------------------------------------\n# Written by SparkFun Electronics, May 2024\n#\n# This python library supports the SparkFun Electroncis Qwiic ecosystem\n#\n# More information on Qwiic is at https://www.sparkfun.com/qwiic\n#\n# Do you like this library? Help support SparkFun. Buy a board!\n#===============================================================================\n# Copyright (c) 2023 SparkFun Electronics\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy \n# of this software and associated documentation files (the \"Software\"), to deal \n# in the Software without restriction, including without limitation the rights \n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n# copies of the Software, and to permit persons to whom the Software is \n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all \n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \n# SOFTWARE.\n#===============================================================================\n\nimport qwiic_otos\nimport sys\nimport time\n\ndef runExample():\n    print(\"\\nQwiic OTOS Example 1 - Basic Readings\\n\")\n\n    # Create instance of device\n    myOtos = qwiic_otos.QwiicOTOS()\n\n    # Check if it's connected\n    if myOtos.is_connected() == False:\n        print(\"The device isn't connected to the system. Please check your connection\", \\\n            file=sys.stderr)\n        return\n\n    # Initialize the device\n    myOtos.begin()\n\n    print(\"Ensure the OTOS is flat and stationary during calibration!\")\n    for i in range(5, 0, -1):\n        print(\"Calibrating in %d seconds...\" % i)\n        time.sleep(1)\n\n    print(\"Calibrating IMU...\")\n\n    # Calibrate the IMU, which removes the accelerometer and gyroscope offsets\n    myOtos.calibrateImu()\n\n    # Reset the tracking algorithm - this resets the position to the origin,\n    # but can also be used to recover from some rare tracking errors\n    myOtos.resetTracking()\n\n    # Main loop\n    while True:\n        # Get the latest position, which includes the x and y coordinates, plus\n        # the heading angle\n        myPosition = myOtos.getPosition()\n\n        # Print measurement\n        print()\n        print(\"Position:\")\n        print(\"X (Inches): {}\".format(myPosition.x))\n        print(\"Y (Inches): {}\".format(myPosition.y))\n        print(\"Heading (Degrees): {}\".format(myPosition.h))\n\n        # Wait a bit so we don't spam the serial port\n        time.sleep(0.5)\n\n        # Alternatively, you can comment out the print and delay code above, and\n        # instead use the following code to rapidly refresh the data\n        # print(\"{}\\t{}\\t{}\".format(myPosition.x, myPosition.y, myPosition.h))\n        # time.sleep(0.01)\n\nif __name__ == '__main__':\n    try:\n        runExample()\n    except (KeyboardInterrupt, SystemExit) as exErr:\n        print(\"\\nEnding Example\")\n        sys.exit(0)\n</code></pre> <p>Then click the run button in the top right corner:</p> <p></p> <p>Run Button</p> <p>You should see the following output in the Shell:</p> <p></p> <p>Example 1 Output</p> <p>Move the sensor around to see how the coordinates change!</p>"},{"location":"examples_xrp/#example-2-set-units","title":"Example 2: Set Units","text":"<p>This example sets the desired units for linear and angular measurements. Can be either meters or inches for linear, and radians or degrees for angular. If not set, the default is inches and degrees. Note that this setting is not stored in the sensor, it's part of the library, so you need to set at the start of all your programs. Assuming you uploaded this example in the procedure above, double-click <code>qwiic_otos_ex2_set_units.py</code> in the Filesystem panel on the left:</p> <p></p> <p><code>qwiic_otos_ex2_set_units.py</code> XRP File Location</p> <p>Alternatively, you can expand the link below and copy and paste the code into a shiny new file and upload to the XRP as described above.</p> Example 2 Python Code <pre><code>#!/usr/bin/env python\n#-------------------------------------------------------------------------------\n# qwiic_otos_ex2_set_units.py\n#\n# This example demonstrates how to change the units of the SparkFun Qwiic\n# Optical Tracking Odometry Sensor (OTOS).\n\n# The OTOS library defaults to inches and degrees, but you can change the\n# units to suit the needs of your project.\n#-------------------------------------------------------------------------------\n# Written by SparkFun Electronics, May 2024\n#\n# This python library supports the SparkFun Electroncis Qwiic ecosystem\n#\n# More information on Qwiic is at https://www.sparkfun.com/qwiic\n#\n# Do you like this library? Help support SparkFun. Buy a board!\n#===============================================================================\n# Copyright (c) 2023 SparkFun Electronics\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy \n# of this software and associated documentation files (the \"Software\"), to deal \n# in the Software without restriction, including without limitation the rights \n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n# copies of the Software, and to permit persons to whom the Software is \n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all \n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \n# SOFTWARE.\n#===============================================================================\n\nimport qwiic_otos\nimport sys\nimport time\n\ndef runExample():\n    print(\"\\nQwiic OTOS Example 2 - Set Units\\n\")\n\n    # Create instance of device\n    myOtos = qwiic_otos.QwiicOTOS()\n\n    # Check if it's connected\n    if myOtos.is_connected() == False:\n        print(\"The device isn't connected to the system. Please check your connection\", \\\n            file=sys.stderr)\n        return\n\n    # Initialize the device\n    myOtos.begin()\n\n    print(\"Ensure the OTOS is flat and stationary during calibration!\")\n    for i in range(5, 0, -1):\n        print(\"Calibrating in %d seconds...\" % i)\n        time.sleep(1)\n\n    print(\"Calibrating IMU...\")\n\n    # Calibrate the IMU, which removes the accelerometer and gyroscope offsets\n    myOtos.calibrateImu()\n\n    # Set the desired units for linear and angular measurements. Can be either\n    # meters or inches for linear, and radians or degrees for angular. If not\n    # set, the default is inches and degrees. Note that this setting is not\n    # stored in the sensor, it's part of the library, so you need to set at the\n    # start of all your programs.\n    myOtos.setLinearUnit(myOtos.kLinearUnitMeters)\n    # myOtos.setLinearUnit(myOtos.kLinearUnitInches)\n    myOtos.setAngularUnit(myOtos.kAngularUnitRadians)\n    # myOtos.setAngularUnit(myOtos.kAngularUnitDegrees)\n\n    # Reset the tracking algorithm - this resets the position to the origin,\n    # but can also be used to recover from some rare tracking errors\n    myOtos.resetTracking()\n\n    # Main loop\n    while True:\n        # Get the latest position, which includes the x and y coordinates, plus\n        # the heading angle\n        myPosition = myOtos.getPosition()\n\n        # Print measurement\n        print()\n        print(\"Position:\")\n        print(\"X (Meters): {}\".format(myPosition.x))\n        print(\"Y (Meters): {}\".format(myPosition.y))\n        print(\"Heading (Radians): {}\".format(myPosition.h))\n\n        # Wait a bit so we don't spam the serial port\n        time.sleep(0.5)\n\nif __name__ == '__main__':\n    try:\n        runExample()\n    except (KeyboardInterrupt, SystemExit) as exErr:\n        print(\"\\nEnding Example\")\n        sys.exit(0)\n</code></pre> <p>Notice the following code snippet - this is the section of code that allows you to choose your units:</p> <p></p> <p>Code Snippet to Change Units</p> <p>Then click the run button in the top right corner:</p> <p></p> <p>Run Button</p> <p>You should see the following output in the Shell:</p> <p></p> <p>Example 2 Output</p>"},{"location":"examples_xrp/#example-3-calibration","title":"Example 3: Calibration","text":"<p>Warning</p> <p>As of firmware version 1.0, these calibration values will be lost after a power cycle, so you will need to set them each time you power up the sensor.</p> <p>The data from the OTOS will likely have minor scaling errors that can be calibrated out. This is especially important for the angular scalar, because an incorrect angle measurement causes the linear measurements to be rotated by the wrong angle in the firmware, which can lead to very inaccurate tracking. Assuming you uploaded this example in the procedure above, double-click <code>qwiic_otos_ex3_calibration.py</code> in the Filesystem panel on the left:</p> <p></p> <p><code>qwiic_otos_ex3_calibration.py</code> XRP File Location</p> <p>Alternatively, you can expand the link below and copy and paste the code into a shiny new file and upload to the XRP as described above.</p> Example 3 Python Code <pre><code>#!/usr/bin/env python\n#-------------------------------------------------------------------------------\n# qwiic_otos_ex3_calibration.py\n#\n# This example demonstrates how to calibrate the SparkFun Qwiic Optical\n# Tracking Odometry Sensor (OTOS).\n\n# This example should be used to calibrate the linear and angular scalars of\n# the OTOS to get the most accurate tracking performance. The linear scalar\n# can be used to compensate for scaling issues with the x and y measurements,\n# while the angular scalar can be used to compensate for scaling issues with\n# the heading measurement. Note that if the heading measurement is off, that\n# can also cause the x and y measurements to be off, so it's recommended to\n# calibrate the angular scalar first.\n#-------------------------------------------------------------------------------\n# Written by SparkFun Electronics, May 2024\n#\n# This python library supports the SparkFun Electroncis Qwiic ecosystem\n#\n# More information on Qwiic is at https:#www.sparkfun.com/qwiic\n#\n# Do you like this library? Help support SparkFun. Buy a board!\n#===============================================================================\n# Copyright (c) 2023 SparkFun Electronics\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy \n# of this software and associated documentation files (the \"Software\"), to deal \n# in the Software without restriction, including without limitation the rights \n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n# copies of the Software, and to permit persons to whom the Software is \n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all \n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \n# SOFTWARE.\n#===============================================================================\n\nimport qwiic_otos\nimport sys\nimport time\n\ndef runExample():\n    print(\"\\nQwiic OTOS Example 3 - Calibration\\n\")\n\n    # Create instance of device\n    myOtos = qwiic_otos.QwiicOTOS()\n\n    # Check if it's connected\n    if myOtos.is_connected() == False:\n        print(\"The device isn't connected to the system. Please check your connection\", \\\n            file=sys.stderr)\n        return\n\n    # Initialize the device\n    myOtos.begin()\n\n    print(\"Ensure the OTOS is flat and stationary during calibration!\")\n    for i in range(5, 0, -1):\n        print(\"Calibrating in %d seconds...\" % i)\n        time.sleep(1)\n\n    print(\"Calibrating IMU...\")\n\n    # The IMU on the OTOS includes a gyroscope and accelerometer, which could\n    # have an offset. Note that as of firmware version 1.0, the calibration\n    # will be lost after a power cycle; the OTOS performs a quick calibration\n    # when it powers up, but it is recommended to perform a more thorough\n    # calibration at the start of all your programs. Note that the sensor must\n    # be completely stationary and flat during calibration! When calling\n    # calibrateImu(), you can specify the number of samples to take and whether\n    # to wait until the calibration is complete. If no parameters are provided,\n    # it will take 255 samples and wait until done; each sample takes about\n    # 2.4ms, so about 612ms total\n    myOtos.calibrateImu()\n\n    # Alternatively, you can specify the number of samples and whether to wait\n    # until it's done. If you don't want to wait, you can asynchronously check\n    # how many samples remain with the code below. Once zero samples remain,\n    # the calibration is done!\n    # myOtos.calibrateImu(255, False)\n    # done = False\n    # while(done == False):\n    #     # Check how many samples remain\n    #     samplesRemaining = myOtos.getImuCalibrationProgress()\n\n    #     # If 0 samples remain, the calibration is done\n    #     if(samplesRemaining == 0):\n    #         done = True\n\n    # Here we can set the linear and angular scalars, which can compensate for\n    # scaling issues with the sensor measurements. Note that as of firmware\n    # version 1.0, these values will be lost after a power cycle, so you will\n    # need to set them each time you power up the sensor. They can be any value\n    # from 0.872 to 1.127 in increments of 0.001 (0.1%). It is recommended to\n    # first set both scalars to 1.0, then calibrate the angular scalar, then\n    # the linear scalar. To calibrate the angular scalar, spin the robot by\n    # multiple rotations (eg. 10) to get a precise error, then set the scalar\n    # to the inverse of the error. Remember that the angle wraps from -180 to\n    # 180 degrees, so for example, if after 10 rotations counterclockwise\n    # (positive rotation), the sensor reports -15 degrees, the required scalar\n    # would be 3600/3585 = 1.004. To calibrate the linear scalar, move the\n    # robot a known distance and measure the error; do this multiple times at\n    # multiple speeds to get an average, then set the linear scalar to the\n    # inverse of the error. For example, if you move the robot 100 inches and\n    # the sensor reports 103 inches, set the linear scalar to 100/103 = 0.971\n    myOtos.setLinearScalar(1.0)\n    myOtos.setAngularScalar(1.0)\n\n    # Reset the tracking algorithm - this resets the position to the origin,\n    # but can also be used to recover from some rare tracking errors\n    myOtos.resetTracking()\n\n    # Main loop\n    while True:\n        # Get the latest position, which includes the x and y coordinates, plus\n        # the heading angle\n        myPosition = myOtos.getPosition()\n\n        # Print measurement\n        print()\n        print(\"Position:\")\n        print(\"X (Inches): {}\".format(myPosition.x))\n        print(\"Y (Inches): {}\".format(myPosition.y))\n        print(\"Heading (Degrees): {}\".format(myPosition.h))\n\n        # Wait a bit so we don't spam the serial port\n        time.sleep(0.5)\n\nif __name__ == '__main__':\n    try:\n        runExample()\n    except (KeyboardInterrupt, SystemExit) as exErr:\n        print(\"\\nEnding Example\")\n        sys.exit(0)\n</code></pre> <p>Then click the run button in the top right corner:</p> <p></p> <p>Run Button</p> <p>Calibrating your bot requires you to move it around a bit. First, set both scalars to 1.0, then calibrate the angular scalar, then the linear scalar. </p> <p>To calibrate the angular scalar, spin the robot by multiple rotations (eg. 10) to get a precise error, then set the scalar to the inverse of the error. Remember that the angle wraps from -180 to 180 degrees, so for example, if after 10 rotations counterclockwise(positive rotation), the sensor reports -15 degrees, the required scalar would be 3600/3585 = 1.004. </p> <p></p> <p>Rotating the Optical Tracking Odometry Sensor</p> <p>To calibrate the linear scalar, move the robot a known distance and measure the error; do this multiple times at multiple speeds to get an average, then set the linear scalar to the inverse of the error. For example, if you move the robot 100 inches and the sensor reports 103 inches, set the linear scalar to 100/103 = 0.971. </p> <p></p> <p>Moving the Optical Tracking Odometry Sensor</p>"},{"location":"examples_xrp/#example-4-setoffsetandposition","title":"Example 4: SetOffsetAndPosition","text":"<p>This example shows how to set the offset for the sensor relative to the center of the robot. The units default to inches and degrees, but if you want to use different units, make sure you specify them before setting the offset. Without setting the offset, the OTOS will report the coordinates of itself. If the offset is set, the OTOS will instead report the coordinates of the center of your robot.</p> <p>Note that the OTOS typically starts tracking from the origin, but if your robot starts at some other location, or you have another source of location information from another sensor that's more accurate, you can send the current location to the OTOS and it will continue tracking from there.</p> <p>Warning</p> <p>As of firmware version 1.0, these values will be lost after a power cycle, so you will need to set them each time you power up the sensor. </p> <p>Assuming you uploaded this example in the procedure above, double-click <code>qwiic_otos_ex4_set_offsets_and_position.py</code> in the Filesystem panel on the left:</p> <p></p> <p><code>qwiic_otos_ex4_set_offsets_and_position.py</code> XRP File Location</p> <p>Alternatively, you can expand the link below and copy and paste the code into a shiny new file and upload to the XRP as described above.</p> Example 4 Python Code <pre><code>#!/usr/bin/env python\n#-------------------------------------------------------------------------------\n# qwiic_otos_ex4_set_offsets_and_position.py\n#\n# This example demonstrates how to set the offset and position of the SparkFun\n# Qwiic Optical Tracking Odometry Sensor (OTOS).\n\n# If your OTOS is mounted to a robot and is not centered, you can specify the\n# offset for the sensor relative to the center of the robot; rather than\n# returning the position of the sensor, the OTOS will calculate and return the\n# position of the robot's center. If you know where your robot is located,\n# such as the starting location or from another sensor, you can send that\n# position to the OTOS and it will continue to track from there.\n#-------------------------------------------------------------------------------\n# Written by SparkFun Electronics, May 2024\n#\n# This python library supports the SparkFun Electroncis Qwiic ecosystem\n#\n# More information on Qwiic is at https:#www.sparkfun.com/qwiic\n#\n# Do you like this library? Help support SparkFun. Buy a board!\n#===============================================================================\n# Copyright (c) 2023 SparkFun Electronics\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy \n# of this software and associated documentation files (the \"Software\"), to deal \n# in the Software without restriction, including without limitation the rights \n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n# copies of the Software, and to permit persons to whom the Software is \n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all \n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \n# SOFTWARE.\n#===============================================================================\n\nimport qwiic_otos\nimport sys\nimport time\n\ndef runExample():\n    print(\"\\nQwiic OTOS Example 4 - Set Offsets and Position\\n\")\n\n    # Create instance of device\n    myOtos = qwiic_otos.QwiicOTOS()\n\n    # Check if it's connected\n    if myOtos.is_connected() == False:\n        print(\"The device isn't connected to the system. Please check your connection\", \\\n            file=sys.stderr)\n        return\n\n    # Initialize the device\n    myOtos.begin()\n\n    print(\"Ensure the OTOS is flat and stationary during calibration!\")\n    for i in range(5, 0, -1):\n        print(\"Calibrating in %d seconds...\" % i)\n        time.sleep(1)\n\n    print(\"Calibrating IMU...\")\n\n    # Calibrate the IMU, which removes the accelerometer and gyroscope offsets\n    myOtos.calibrateImu()\n\n    # Assuming you've mounted your sensor to a robot and it's not centered,\n    # you can specify the offset for the sensor relative to the center of the\n    # robot. The units default to inches and degrees, but if you want to use\n    # different units, specify them before setting the offset! Note that as of\n    # firmware version 1.0, these values will be lost after a power cycle, so\n    # you will need to set them each time you power up the sensor. For example,\n    # if the sensor is mounted 5 inches to the left (negative X) and 10 inches\n    # forward (positive Y) of the center of the robot, and mounted 90 degrees\n    # clockwise (negative rotation) from the robot's orientation, the offset\n    # would be {-5, 10, -90}. These can be any value, even the angle can be\n    # tweaked slightly to compensate for imperfect mounting (eg. 1.3 degrees).\n    offset = qwiic_otos.Pose2D(-5, 10, -90)\n    myOtos.setOffset(offset)\n\n    # Reset the tracking algorithm - this resets the position to the origin,\n    # but can also be used to recover from some rare tracking errors\n    myOtos.resetTracking()\n\n    # After resetting the tracking, the OTOS will report that the robot is at\n    # the origin. If your robot does not start at the origin, or you have\n    # another source of location information (eg. vision odometry), you can set\n    # the OTOS location to match and it will continue to track from there.\n    currentPosition = qwiic_otos.Pose2D(0, 0, 0)\n    myOtos.setPosition(currentPosition)\n\n    # Main loop\n    while True:\n        # Get the latest position, which includes the x and y coordinates, plus\n        # the heading angle\n        myPosition = myOtos.getPosition()\n\n        # Print measurement\n        print()\n        print(\"Position:\")\n        print(\"X (Inches): {}\".format(myPosition.x))\n        print(\"Y (Inches): {}\".format(myPosition.y))\n        print(\"Heading (Degrees): {}\".format(myPosition.h))\n\n        # Wait a bit so we don't spam the serial port\n        time.sleep(0.5)\n\nif __name__ == '__main__':\n    try:\n        runExample()\n    except (KeyboardInterrupt, SystemExit) as exErr:\n        print(\"\\nEnding Example\")\n        sys.exit(0)\n</code></pre> <p>Then click the run button in the top right corner:</p> <p></p> <p>Run Button</p> <p>The offset values depend on the axes conventions that you choose for your robot. Below are 2 animations showing ENU (East-North-Up) and NWU (North-West-Up) axes conventions with the XRP, and the required offset values for the indicated location of the OTOS for each. In this case, the sensor is mounted 2 inches to the right (\"East\"), 4 inches forward (\"North\"), and with the x-axis to the right (\"East\").</p> <p></p> <p>OTOS offsets with ENU axes conventions</p> <p></p> <p>OTOS offsets with NWU axes conventions</p> <p>With the ENU convention, the OTOS axes are aligned with the robot axes, so the offset angle is zero. With the NWU convention, the OTOS axes are rotated -90 degrees (right-hand rule about the \"up\" z-axis) relative to the robot axes. So the offset values would be <code>{2, 4, 0}</code> for ENU and <code>{4, -2, -90}</code> for NWU. These can be any value, even the angle can be tweaked slightly to compensate for imperfect mounting (eg. 1.3 degrees).</p> <p>These four examples cover the basics - there are more examples to explore in the GitHub Repo! </p>"},{"location":"file_issue/","title":"Did we make a mistake?","text":"<p>Spot something wrong? Please let us know. </p> <p>Attention</p> <p>This is not where customers should seek assistance on a product. If you require technical assistance or have questions about a product that is not working as expected, please head over to the SparkFun Technical Assistance page for some initial troubleshooting.  SparkFun Technical Assistance Page </p> <p>If you can't find what you need there, you'll need a Forum Account to search product forums and post questions.</p>"},{"location":"file_issue/#discrepancies-in-the-documentation","title":"Discrepancies in the Documentation","text":"<p>All of this documentation can be modified by you! Please help us make it better.</p> <ul> <li>The documentation files for these pages are contained in the <code>docs</code> folder of the SparkFun Optical Tracking Odometry Sensor - PAA5160E1 (Qwiic) repository.</li> </ul>"},{"location":"file_issue/#spot-something-wrong","title":"Spot something wrong?","text":"<p>If a section of the documentation is incorrect, please open an issue and let us know.</p>"},{"location":"file_issue/#do-you-have-a-suggested-correction","title":"Do you have a suggested correction?","text":"<ol> <li>With a GitHub account, fork this repo</li> <li>Add your correction(s) or improvement(s) to the markdown file(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvement(s) to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"file_issue/#problems-in-the-hardware-design","title":"Problems in the Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun Optical Tracking Odometry Sensor - PAA5160E1 (Qwiic) repository. </li> </ul>"},{"location":"file_issue/#does-something-not-make-sense","title":"Does something not make sense?","text":"<p>If part of the design is confusing, please open an issue and let us know.</p>"},{"location":"file_issue/#did-we-forget-to-include-an-important-function-of-the-board","title":"Did we forget to include an important function of the board?","text":"<ul> <li>Please keep in mind that we may intentionally exclude certain functions of the board to meet our product design requirements. (For example, our Qwiic Micro boards are intended to fit on a small board layout and only use I<sup>2</sup>C communication; therefore, we may not have the SPI and interrupt pins available for users.)</li> <li>If part of the board's functionality is missing, please open an issue and file a feature request.</li> </ul>"},{"location":"file_issue/#do-you-wish-to-contribute-directly-to-improving-the-board-design","title":"Do you wish to contribute directly to improving the board design?","text":"<ol> <li>With a GitHub account, Fork this repo</li> <li>Add your design improvement(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvement(s), if they are within our board design standards and meet our product design requirements, we will flag these changes for our next board revision. (Please note, that even if your suggestion is accepted, these changes may not be immediate. We may have to cycle through our current product inventory first.)</li> </ul> </li> </ol>"},{"location":"hard_copy/","title":"Hard copy","text":"<p>Need to download or print our hookup guide?</p> <ul> <li>Print  (Single-Page View)<ul> <li>To save as a <code>*.pdf</code> file, select the Printer or Destination labeled Save as PDF. (Instructions will vary based on the browser)</li> </ul> </li> </ul>"},{"location":"hardware_assembly/","title":"XRP","text":"<p>The SparkFun Optical Tracking Odometry Sensor needs to be rigidly mounted to a robot chassis and oriented flat to the floor in order to get accurate data. If you don't already have a mount, there are a few 3D printing models you can use. That said, you may need to design your own mount for this board, depending on your use case. </p> <p>The height that the sensor needs to be mounted will be dependent on the surface being read. If you have a shiny or glossy surface, you should be able to mount the sensor anywhere in the range of 10mm to 27mm, measured from the front face of the optical sensor. If you have a darker or more diffuse surface, you may need to mount the sensor at the low-end of that range. You'll need to test to determine what height works for your surface.</p> <p>You can access the XRP mount on Printables:  </p>      [XRP Mount on Printables](https://www.printables.com/model/872179-odometry-clip-for-xrp){ .md-button .md-button--primary target=\"_blank\" }  <p>Warning</p> <p>Accurate readings require that the sensor is mounted correctly; attempting to move the sensor by hand may work, but tracking accuracy will suffer.</p> <p>The image below shows the 3D mounted clip with the Optical Tracking Sensor attached to an XRP: </p> <p></p> <p>Optical Tracking Sensor Mounted to the XRP</p> <p>Here is the underside of the XRP with the Optical Tracking Sensor attached via the mounting clip: </p> <p></p> <p>Optical Tracking Sensor Mounted to the XRP</p> <p>Attention</p> <p>Reminder - make sure you peel off the yellow kapton tape! </p> <p></p> <p>Peel off the Kapton tape before use</p>"},{"location":"hardware_assembly_FTC/","title":"FTC","text":"<p>The SparkFun Optical Tracking Odometry Sensor needs to be rigidly mounted to a robot chassis and oriented flat to the floor in order to get accurate data. If you don't already have a mount, there are a few 3D printing models you can use. That said, you may need to design your own mount for this board, depending on your use case. </p> <p>Note here that we are using the foam surface typical of FIRST Tech Challenge competitions and the sensor is mounted at 10mm from the surface.</p> <p>Warning</p> <p>Accurate readings require that the sensor is mounted correctly; attempting to move the sensor by hand may work, but tracking accuracy will suffer.</p> <p>The FTC mounts are available on Onshape: </p>      [FTC mounts on Onshape](https://cad.onshape.com/documents/1253798610182bf3a147f431/w/11cc45e6a7c8080b22bb8377/e/d4827c4f09d804607ba1824b){ .md-button .md-button--primary target=\"_blank\" }  <p>In addition, instructions for the FTC mounts are available here:</p>      [Instructions for FTC mounts]( https://docs.google.com/document/d/14oHPdummdtDlF2BijsM5kqbD6MTwzaQFkbJ2jo99SUI/edit){ .md-button .md-button--primary target=\"_blank\" }  <p>The image below shows the 3D mounted clip with the Optical Tracking Sensor attached to an FTC Bot: </p> <p></p> <p>Optical Tracking Sensor Mounted to the FTC Bot</p> <p>FIRST Tech Challenge</p> <p></p> <p>FIRST Tech Challenge: Note here that for the foam competition files, the sensor really needs to be mounted at exactly 10mm from the surface with a tolerance of +/ 1mm. Beyond that, the tracking is less accurate; beyond +/- 3mm, and it can't track the foam surface at all.</p> <p>Here is the underside of the FTC Bot with the Optical Tracking Sensor attached via the mounting clip: </p> <p></p> <p>Optical Tracking Sensor Mounted to the FTC Bot</p> <p>Using the Flexible Qwiic to STEMMA Cable - 500mm, you'll need to attach the sensor via one of the I<sup>2</sup>C connectors on the Control Hub like so:</p> <p></p> <p>I<sup>2</sup>C connection location</p> <p>Attention</p> <p>Reminder - make sure you peel off the yellow kapton tape! </p> <p></p> <p>Peel off the Kapton tape before use</p>"},{"location":"hardware_overview/","title":"Hardware Overview","text":""},{"location":"hardware_overview/#optical-tracking-sensor-paa5160","title":"Optical Tracking Sensor - PAA5160","text":"<p>The PAA5160E1-Q from PixArt Imaging has a tracking speed of 2.5m/s and a typical tracking error rate of 3~5% within a working range of 10mm to 27mm. With an 850nm Class 1 laser, a resolution of 20,000 DPI, and a frame rate of 20,000 fps, it is ideal for surfaces like concrete, epoxy, laminated wood, or glossy/semi-glossy flooring. That said, dark or diffuse surfaces are more challenging, so these specs may vary based on the surfaces that are being used. More information can be found in the datasheet.</p> <p></p> <p>Optical Tracking Sensor - PAA5160</p> <p>Warning</p> <p>The laser on this module is a Class 1, 850nm laser. Please use appropriate caution.   Lasers... </p>"},{"location":"hardware_overview/#6-dof-imu-lsm6dso","title":"6-DoF IMU - LSM6DSO","text":"<p>The LSM6DSO from STMicroelectronics has a 3-axis digital accelerometer and 3-axis digital gyroscope featuring a full-scale acceleration range of \u00b12/\u00b14/\u00b18/\u00b116 g and an angular rate range of \u00b1125/\u00b1250/\u00b1500/\u00b11000/\u00b12000 dps. For more information, refer to the datasheet. </p> <p></p> <p>LSM6DSO 6-DOF IMU Accelerometer</p>"},{"location":"hardware_overview/#microcontroller-stm32c0","title":"Microcontroller - STM32C0","text":"<p>The STM32C011F4U6 microcontroller has a high-performance Arm\u00ae Cortex\u00ae-M0+ 32-bit RISC core operating at up to 48 MHz frequency. It incorporates a memory protection unit (MPU), high-speed embedded memory (6 Kbytes of SRAM and up to 32 Kbytes of flash program memory with read and write protection), DMA, an extensive range of system functions, enhanced I/Os, and peripherals. The device offers standard communication interfaces (one I<sup>2</sup>C, one SPI / one I2S, and two USARTs), one 12-bit ADC (2.5 MSps) with up to 15 channels, a low-power RTC, an advanced control PWM timer, four general-purpose 16-bit timers, two watchdog timers, and a SysTick timer. For more information, refer to the datasheet.</p> <p></p> <p>STM32 Processor</p>"},{"location":"hardware_overview/#power","title":"Power","text":"<p>The LED indicator lights when power is provided to the board. </p> <p></p> <p>Power LED</p>"},{"location":"hardware_overview/#qwiic-connectors","title":"Qwiic Connectors","text":"<p>The Qwiic Connectors on the SparkFun Optical Tracking Odometry Sensor - PAA5160E1 (Qwiic) provide power and I<sup>2</sup>C connectivity simultaneously. The I<sup>2</sup>C address is 0x17.</p> <p></p> <p>Qwiic Connectors</p>"},{"location":"hardware_overview/#gpio","title":"GPIO","text":"<p>The PTH pins on the side of the board allow you to provide power, access the I<sup>2</sup>C Data and Clock lines, and there are two pins available for UART/generic programming purposes. In normal operation, IO9 acts as a \"data ready\" interrupt; this pin could be used to synchronize measurements if needed. Outside of normal operation, IO9 and IO10 provide a UART interface that can be used for firmware updates, see instructions here. </p> <p></p> <p>GPIO</p>"},{"location":"hardware_overview/#debugging-test-points","title":"Debugging Test Points","text":"<p>We've broken out test points for serial wire debugging if you wish to access flash memory or directly program the board. They are located here: </p> <p></p> <p>Debugging Test Points</p>"},{"location":"hardware_overview/#jumpers","title":"Jumpers","text":"Never modified a jumper before? <p>Check out our Jumper Pads and PCB Traces tutorial for a quick introduction! <p>      How to Work with Jumper Pads and PCB Traces </p></p>"},{"location":"hardware_overview/#power-jumper","title":"Power Jumper","text":"<p>If you are concerned about power consumption, need to run dark, or just really don't like LEDs, cut the jumper highlighted below to disconnect power from the LED on the front of the board. </p> <p></p> <p>Power Jumper</p>"},{"location":"hardware_overview/#i2c-jumper","title":"I<sup>2</sup>C Jumper","text":"<p>If you choose to use one or more Qwiic breakouts in your project, it is important to note that this board comes equipped with pull-up resistors on the clock and data pins. If you are daisy-chaining multiple Qwiic devices, you will want to cut this jumper; if multiple sensors are connected to the bus with the pull-up resistors enabled, the parallel equivalent resistance will create too strong of a pull-up for the bus to operate correctly. As a general rule of thumb, disable all but one pair of pull-up resistors if multiple devices are connected to the bus. To disable the pull up resistors, use an X-acto knife to cut the joints between the jumper pads highlighted below.</p> <p></p> <p>I<sup>2</sup>C Jumper</p>"},{"location":"hardware_overview/#board-dimensions","title":"Board Dimensions","text":"<p>The board dimensions are illustrated in the drawing below; the listed measurements are in inches.</p> <p></p> <p>SparkFun Optical Tracking Odometry Sensor Board Dimensions</p> Need more measurements? <p>For more information about the board's dimensions, users can download the Eagle files. These files can be opened in Eagle and additional measurements can be made with the dimensions tool.</p>  Eagle - Free Download! <p>Eagle is a CAD program for electronics that is free to use for hobbyists and students. However, it does require an account registration to utilize the software.</p> <p> Download fromAutodesk primary logo </p>  Dimensions Tool <p>This video from Autodesk demonstrates how to utilize the dimensions tool in Eagle, to include additional measurements:</p> <p> </p>"},{"location":"introduction/","title":"Introduction","text":"<ul> <li> <p> SparkFun Optical Tracking Odometry Sensor - PAA5160E1 (Qwiic) SKU: SEN-24904 <p> </p> <li> <p>The SparkFun Qwiic Optical Tracking Odometry Sensor empowers you to elevate your robot's navigation capabilities with exceptional precision and streamlined integration. This compact, all-in-one sensor leverages the power of the PAA5160E1 chip from PixArt Imaging Inc., delivering accurate dual-axis motion data across various hard floor surfaces. But that's not all! This sensor boasts a powerful built-in 6-axis Inertial Measurement Unit (IMU) and an onboard microcontroller that performs real-time sensor fusion and tracking algorithms.</p> <p> Purchase from SparkFun  </p> </li>"},{"location":"introduction/#required-materials","title":"Required Materials","text":"<p>To follow along with this tutorial, you will need the following materials. You may not need everything though depending on what you have. Add it to your cart, read through the guide, and adjust the cart as necessary.</p> SparkFun Optical Tracking Odometry Sensor - PAA5160E1 (Qwiic)              SEN-24904          Flexible Qwiic to STEMMA Cable - 500mm              CAB-25596          Qwiic Cable - 100mmc             PRT-14427          USB micro-B Cable - 6 Foot              CAB-10215          Experiential Robotics Platform (XRP) Kit - Beta              KIT-22230          SparkFun RedBoard Qwiic              DEV-15123"},{"location":"introduction/#suggested-reading","title":"Suggested Reading","text":"<p>Below are a few tutorials that may help users familiarize themselves with various aspects of the board.</p> <ul> <li> <p> I2C </p> </li> <li> <p> Serial Terminal Basics </p> </li> </ul> <p>The SparkFun Optical Tracking Odometry Sensor - PAA5160E1 (Qwiic) takes advantage of the Qwiic connect system. We recommend familiarizing yourself with the Logic Levels and I<sup>2</sup>C tutorials.  Click on the banner above to learn more about Qwiic products.</p>"},{"location":"resources/","title":"Resources","text":"<p>For more resources related to the SparkFun SparkFun Optical Tracking Odometry Sensor, check out the links listed here: </p> <ul> <li>Product Page</li> <li>Schematic (PDF)</li> <li>Eagle Files (ZIP)</li> <li>Board Dimensions(PNG)</li> <li>Hardware GitHub Repository</li> <li>Optical Tracking Odometry Sensor Register Map (PDF)</li> </ul> <p>Libraries/Packages: </p> <ul> <li>Arduino Library GitHub Repository</li> <li>SparkFun Optical Tracking Odometry Sensor Python Package GitHub</li> <li>SparkFun Optical Tracking Odometry Sensor Java Library GitHub</li> </ul> <p>Visualization Python Script: </p> <ul> <li>XRP Visualization Script</li> </ul> <p>XRP Resources:</p> <ul> <li>XRP 3D Printed Mount on Printables</li> <li>XRP Info Page</li> </ul> <p>First Tech Challenge Resources: </p> <ul> <li>FTC mounts on Onshape </li> <li>Instructions for FTC mounts</li> </ul> <p>Datasheets: </p> <ul> <li>Optical Tracking Sensor - PAA5160 Datasheet</li> <li>6-DoF IMU - LSM6DSO Datasheet</li> <li>Microcontroller - STM32C0 Datasheet</li> </ul>"},{"location":"single_page/","title":"Single page","text":"<ul> <li> <p> SparkFun Optical Tracking Odometry Sensor - PAA5160E1 (Qwiic) SKU: SEN-24904 <p> </p> <li> <p>The SparkFun Qwiic Optical Tracking Odometry Sensor empowers you to elevate your robot's navigation capabilities with exceptional precision and streamlined integration. This compact, all-in-one sensor leverages the power of the PAA5160E1 chip from PixArt Imaging Inc., delivering accurate dual-axis motion data across various hard floor surfaces. But that's not all! This sensor boasts a powerful built-in 6-axis Inertial Measurement Unit (IMU) and an onboard microcontroller that performs real-time sensor fusion and tracking algorithms.</p> <p> Purchase from SparkFun  </p> </li>"},{"location":"single_page/#required-materials","title":"Required Materials","text":"<p>To follow along with this tutorial, you will need the following materials. You may not need everything though depending on what you have. Add it to your cart, read through the guide, and adjust the cart as necessary.</p> SparkFun Optical Tracking Odometry Sensor - PAA5160E1 (Qwiic)              SEN-24904          Flexible Qwiic to STEMMA Cable - 500mm              CAB-25596          Qwiic Cable - 100mmc             PRT-14427          USB micro-B Cable - 6 Foot              CAB-10215          Experiential Robotics Platform (XRP) Kit - Beta              KIT-22230          SparkFun RedBoard Qwiic              DEV-15123"},{"location":"single_page/#suggested-reading","title":"Suggested Reading","text":"<p>Below are a few tutorials that may help users familiarize themselves with various aspects of the board.</p> <ul> <li> <p> I2C </p> </li> <li> <p> Serial Terminal Basics </p> </li> </ul> <p>The SparkFun Optical Tracking Odometry Sensor - PAA5160E1 (Qwiic) takes advantage of the Qwiic connect system. We recommend familiarizing yourself with the Logic Levels and I<sup>2</sup>C tutorials.  Click on the banner above to learn more about Qwiic products.</p>"},{"location":"single_page/#hardware-overview","title":"Hardware Overview","text":""},{"location":"single_page/#optical-tracking-sensor-paa5160","title":"Optical Tracking Sensor - PAA5160","text":"<p>The PAA5160E1-Q from PixArt Imaging has a tracking speed of 2.5m/s and a typical tracking error rate of 3~5% within a working range of 10mm to 27mm. With an 850nm Class 1 laser, a resolution of 20,000 DPI, and a frame rate of 20,000 fps, it is ideal for surfaces like concrete, epoxy, laminated wood, or glossy/semi-glossy flooring. That said, dark or diffuse surfaces are more challenging, so these specs may vary based on the surfaces that are being used. More information can be found in the datasheet.</p> <p></p> <p>Optical Tracking Sensor - PAA5160</p> <p>Warning</p> <p>The laser on this module is a Class 1, 850nm laser. Please use appropriate caution.   Lasers... </p>"},{"location":"single_page/#6-dof-imu-lsm6dso","title":"6-DoF IMU - LSM6DSO","text":"<p>The LSM6DSO from STMicroelectronics has a 3-axis digital accelerometer and 3-axis digital gyroscope featuring a full-scale acceleration range of \u00b12/\u00b14/\u00b18/\u00b116 g and an angular rate range of \u00b1125/\u00b1250/\u00b1500/\u00b11000/\u00b12000 dps. For more information, refer to the datasheet. </p> <p></p> <p>LSM6DSO 6-DOF IMU Accelerometer</p>"},{"location":"single_page/#microcontroller-stm32c0","title":"Microcontroller - STM32C0","text":"<p>The STM32C011F4U6 microcontroller has a high-performance Arm\u00ae Cortex\u00ae-M0+ 32-bit RISC core operating at up to 48 MHz frequency. It incorporates a memory protection unit (MPU), high-speed embedded memory (6 Kbytes of SRAM and up to 32 Kbytes of flash program memory with read and write protection), DMA, an extensive range of system functions, enhanced I/Os, and peripherals. The device offers standard communication interfaces (one I<sup>2</sup>C, one SPI / one I2S, and two USARTs), one 12-bit ADC (2.5 MSps) with up to 15 channels, a low-power RTC, an advanced control PWM timer, four general-purpose 16-bit timers, two watchdog timers, and a SysTick timer. For more information, refer to the datasheet.</p> <p></p> <p>STM32 Processor</p>"},{"location":"single_page/#power","title":"Power","text":"<p>The LED indicator lights when power is provided to the board. </p> <p></p> <p>Power LED</p>"},{"location":"single_page/#qwiic-connectors","title":"Qwiic Connectors","text":"<p>The Qwiic Connectors on the SparkFun Optical Tracking Odometry Sensor - PAA5160E1 (Qwiic) provide power and I<sup>2</sup>C connectivity simultaneously. The I<sup>2</sup>C address is 0x17.</p> <p></p> <p>Qwiic Connectors</p>"},{"location":"single_page/#gpio","title":"GPIO","text":"<p>The PTH pins on the side of the board allow you to provide power, access the I<sup>2</sup>C Data and Clock lines, and there are two pins available for UART/generic programming purposes. In normal operation, IO9 acts as a \"data ready\" interrupt; this pin could be used to synchronize measurements if needed. Outside of normal operation, IO9 and IO10 provide a UART interface that can be used for firmware updates, see instructions here. </p> <p></p> <p>GPIO</p>"},{"location":"single_page/#debugging-test-points","title":"Debugging Test Points","text":"<p>We've broken out test points for serial wire debugging if you wish to access flash memory or directly program the board. They are located here: </p> <p></p> <p>Debugging Test Points</p>"},{"location":"single_page/#jumpers","title":"Jumpers","text":"Never modified a jumper before? <p>Check out our Jumper Pads and PCB Traces tutorial for a quick introduction! <p>      How to Work with Jumper Pads and PCB Traces </p></p>"},{"location":"single_page/#power-jumper","title":"Power Jumper","text":"<p>If you are concerned about power consumption, need to run dark, or just really don't like LEDs, cut the jumper highlighted below to disconnect power from the LED on the front of the board. </p> <p></p> <p>Power Jumper</p>"},{"location":"single_page/#i2c-jumper","title":"I<sup>2</sup>C Jumper","text":"<p>If you choose to use one or more Qwiic breakouts in your project, it is important to note that this board comes equipped with pull-up resistors on the clock and data pins. If you are daisy-chaining multiple Qwiic devices, you will want to cut this jumper; if multiple sensors are connected to the bus with the pull-up resistors enabled, the parallel equivalent resistance will create too strong of a pull-up for the bus to operate correctly. As a general rule of thumb, disable all but one pair of pull-up resistors if multiple devices are connected to the bus. To disable the pull up resistors, use an X-acto knife to cut the joints between the jumper pads highlighted below.</p> <p></p> <p>I<sup>2</sup>C Jumper</p>"},{"location":"single_page/#board-dimensions","title":"Board Dimensions","text":"<p>The board dimensions are illustrated in the drawing below; the listed measurements are in inches.</p> <p></p> <p>SparkFun Optical Tracking Odometry Sensor Board Dimensions</p> Need more measurements? <p>For more information about the board's dimensions, users can download the Eagle files. These files can be opened in Eagle and additional measurements can be made with the dimensions tool.</p>  Eagle - Free Download! <p>Eagle is a CAD program for electronics that is free to use for hobbyists and students. However, it does require an account registration to utilize the software.</p> <p> Download fromAutodesk primary logo </p>  Dimensions Tool <p>This video from Autodesk demonstrates how to utilize the dimensions tool in Eagle, to include additional measurements:</p> <p> </p>"},{"location":"single_page/#hardware-assembly","title":"Hardware Assembly","text":"<p>The SparkFun Optical Tracking Odometry Sensor needs to be rigidly mounted to a robot chassis and oriented flat to the floor in order to get accurate data. If you don't already have a mount, there are a few 3D printing models you can use. That said, you may need to design your own mount for this board, depending on your use case. </p> <p>The height that the sensor needs to be mounted will be dependent on the surface being read. If you have a shiny or glossy surface, you should be able to mount the sensor anywhere in the range of 10mm to 27mm, measured from the front face of the optical sensor. If you have a darker or more diffuse surface, you may need to mount the sensor at the low-end of that range. You'll need to test to determine what height works for your surface.</p> <p>You can access the XRP mount on Printables:  </p>      [XRP Mount on Printables](https://www.printables.com/model/872179-odometry-clip-for-xrp){ .md-button .md-button--primary target=\"_blank\" }  <p>Warning</p> <p>Accurate readings require that the sensor is mounted correctly; attempting to move the sensor by hand may work, but tracking accuracy will suffer.</p> <p>The image below shows the 3D mounted clip with the Optical Tracking Sensor attached to an XRP: </p> <p></p> <p>Optical Tracking Sensor Mounted to the XRP</p> <p>Here is the underside of the XRP with the Optical Tracking Sensor attached via the mounting clip: </p> <p></p> <p>Optical Tracking Sensor Mounted to the XRP</p> <p>Attention</p> <p>Reminder - make sure you peel off the yellow kapton tape! </p> <p></p> <p>Peel off the Kapton tape before use</p>"},{"location":"single_page/#hardware-assembly-ftc","title":"Hardware Assembly - FTC","text":"<p>The SparkFun Optical Tracking Odometry Sensor needs to be rigidly mounted to a robot chassis and oriented flat to the floor in order to get accurate data. If you don't already have a mount, there are a few 3D printing models you can use. That said, you may need to design your own mount for this board, depending on your use case. </p> <p>Note here that we are using the foam surface typical of FIRST Tech Challenge competitions and the sensor is mounted at 10mm from the surface.</p> <p>Warning</p> <p>Accurate readings require that the sensor is mounted correctly; attempting to move the sensor by hand may work, but tracking accuracy will suffer.</p> <p>The FTC mounts are available on Onshape: </p>      [FTC mounts on Onshape](https://cad.onshape.com/documents/1253798610182bf3a147f431/w/11cc45e6a7c8080b22bb8377/e/d4827c4f09d804607ba1824b){ .md-button .md-button--primary target=\"_blank\" }  <p>In addition, instructions for the FTC mounts are available here:</p>      [Instructions for FTC mounts]( https://docs.google.com/document/d/14oHPdummdtDlF2BijsM5kqbD6MTwzaQFkbJ2jo99SUI/edit){ .md-button .md-button--primary target=\"_blank\" }  <p>The image below shows the 3D mounted clip with the Optical Tracking Sensor attached to an FTC Bot: </p> <p></p> <p>Optical Tracking Sensor Mounted to the FTC Bot</p> <p>FIRST Tech Challenge</p> <p></p> <p>FIRST Tech Challenge: Note here that for the foam competition files, the sensor really needs to be mounted at exactly 10mm from the surface with a tolerance of +/ 1mm. Beyond that, the tracking is less accurate; beyond +/- 3mm, and it can't track the foam surface at all.</p> <p>Here is the underside of the FTC Bot with the Optical Tracking Sensor attached via the mounting clip: </p> <p></p> <p>Optical Tracking Sensor Mounted to the FTC Bot</p> <p>Using the Flexible Qwiic to STEMMA Cable - 500mm, you'll need to attach the sensor via one of the I<sup>2</sup>C connectors on the Control Hub like so:</p> <p></p> <p>I<sup>2</sup>C connection location</p> <p>Attention</p> <p>Reminder - make sure you peel off the yellow kapton tape! </p> <p></p> <p>Peel off the Kapton tape before use</p>"},{"location":"single_page/#software-setup-arduino","title":"Software Setup - Arduino","text":"<p>Attention</p> <p>If this is your first time using Arduino, please review our tutorial on installing the Arduino IDE. If you have not previously installed an Arduino library, please check out our installation guide.</p> <p>We've written a library to get you started with the SparkFun Optical Tracking Odometry Sensor. You can obtain this library through the Arduino Library Manager by searching for \"Odometry\" and installing the latest version from SparkFun. If you prefer downloading libraries manually, you can grab them from the GitHub Repository.</p>      [SparkFun Optical Tracking Odometry Sensor Arduino Library GitHub](https://github.com/sparkfun/SparkFun_Qwiic_OTOS_Arduino_Library/archive/refs/heads/main.zip){ .md-button .md-button--primary }  <p>In addition to the library provided here, we have written a Python script that allows you to visualize the XRP in real time. Download via the button below. </p>      [XRP Visualization Script](assets/SparkFun_OTOS_XRP_Visualization.zip){ .md-button .md-button--primary download=\"SparkFun_OTOS_XRP_Visualization.zip\" }  <p></p> <p>Visualization Script in Action</p>"},{"location":"single_page/#software-setup-python","title":"Software Setup - Python","text":"<p>Attention</p> <p>If this is your first time working with Python, there are quite a few useful tutorials on getting started. The Python Programming Section of our Getting Started with the Raspberry Pi Tutorial has some good basic information and resources for getting started with Python. </p>"},{"location":"single_page/#linuxraspberry-pi-variants","title":"Linux/Raspberry Pi Variants","text":"<p>We've written a python package to get you started with the SparkFun Optical Tracking Odometry Sensor. It's been included in the SparkFun Qwiic Python package, which aggregates all Python Qwiic drivers/modules to provide a single entity for Qwiic within a Python environment. The Qwiic_Py GitHub Library ReadMe has more information on the Qwiic Python package. </p> <p>If you already have your Qwiic Python package installed, you can update it with the following command: </p> <pre><code>pip install --upgrade sparkfun-qwiic\n</code></pre> <p>If you don't have the Qwiic Python package installed already, you can install it with the following command: </p> <pre><code>pip install sparkfun-qwiic\n</code></pre> <p>If you prefer to install just this package, use the following command: </p> <pre><code>pip install sparkfun-qwiic-otos\n</code></pre> <p>If you prefer downloading the code to build and install the package manually, you can grab them from the GitHub Repository.</p>      [SparkFun Optical Tracking Odometry Sensor Python Package GitHub](https://github.com/sparkfun/Qwiic_OTOS_Py/archive/refs/heads/master.zip){ .md-button .md-button--primary }  <p>Attention</p> <p>If you are working with a Raspberry Pi and are using the new Bookworm distribution of the Raspberry Pi OS, refer to these instructions to setup a virtual environment.  </p> <p>Make sure to include the --system-site-packages flag:python3 -m venv  --system-site-packages  <p>Then it is possible to install the packages using pip. </p>"},{"location":"single_page/#xrpmicrocontrollers","title":"XRP/MicroControllers","text":"<p>If you are working with the XRP or other microcontroller, pip will not work for you. Instead, you'll need to install the Qwiic_I2C_Py driver as well as the Qwiic_OTOS driver. </p> <p>Attention</p> <p>These instructions are written for the XRP using the XRPCode IDE. However the setup process is very similar for MicroPython and CircuitPython on any other board, so you should be able to follow along with these instructions using your IDE of choice!</p>"},{"location":"single_page/#install-qwiic_i2c_py","title":"Install Qwiic_I2C_Py","text":"<p>Qwiic_I2C_Py is a generic I2C driver we have created to work on various platforms (such as MicroPython). Our Qwiic Python device drivers take advantage of Qwiic_I2C_Py to function correctly on any of the supported platforms, so it is a required dependency to use our OTOS Python driver.</p> <p>Fist, go to the Qwiic_I2C_Py repository and download it as a .zip file. Once downloaded, extract the <code>qwiic_i2c</code> folder within.</p> <p>Connect your XRP to your computer over USB, navigate to the XRPCode IDE, and connect to your XRP. For usage information, see the XRPCode User Guide.</p> <p>Create a new folder within the <code>lib</code> directory (right-click on the folder), and name it <code>qwiic_i2c</code>.</p> <p></p> <p>Create a new folder in the <code>lib</code> directory</p> <p></p> <p>Name the folder <code>qwiic_i2c</code></p> <p>Upload the files from the previously extracted <code>qwiic_i2c</code> folder into the new folder you just created on the XRP. From the File menu, choose the Upload to XRP option: </p> <p></p> <p>Choose the \"Upload to XRP\" option</p> <p>Then select the extracted files: </p> <p></p> <p>Select the extracted I2C Files</p> <p>Then choose the newly created <code>qwiic_i2c</code> folder on the XRP:</p> <p></p> <p>Choose the newly created <code>qwiic_i2c</code> folder</p> <p>Uploading...</p> <p></p> <p>Update in Progress</p> <p>You can test to confirm correct installation by typing <code>import qwiic_i2c</code> followed by <code>qwiic_i2c.get_i2c_driver().scan()</code> in the Shell. If no errors are printed, then the Qwiic_I2C_Py driver has been installed correctly!</p> <p></p> <p>Testing the install</p>"},{"location":"single_page/#install-qwiic_otos_py","title":"Install Qwiic_OTOS_Py","text":"<p>Fist, go to the Qwiic_OTOS_Py repository and download just the <code>qwiic_otos.py</code> file.</p> <p>Connect your XRP to your computer over USB, navigate to the XRPCode editor, and connect to your XRP. For usage information, see the XRPCode User Guide.</p> <p>Upload the <code>qwiic_otos.py</code> file into the <code>lib</code> folder on the XRP. From the File menu, choose the Upload to XRP option: </p> <p></p> <p>Select the \"Upload to XRP\" Option from the File Menu</p> <p>Select the qwiic_otos.py file: </p> <p></p> <p>Select the qwiic_otos.py file</p> <p>Then select the lib folder on the XRP:</p> <p></p> <p>Select the lib folder on the XRP</p> <p>Updating... </p> <p></p> <p>Updating</p> <p>You can test to confirm correct installation by typing <code>import qwiic_otos</code> followed by <code>qwiic_otos.QwiicOTOS().is_connected()</code> in the Shell. If no errors are printed, then the Qwiic_OTOS_Py driver has been installed correctly!</p> <p>Testing the install:</p> <p></p> <p>Testing the install</p>"},{"location":"single_page/#visualization","title":"Visualization","text":"<p>In addition to the package provided here, we have written a Python script that allows you to visualize the XRP in real time. Download via the button below. </p>      [XRP Visualization Script](assets/SparkFun_OTOS_XRP_Visualization.zip){ .md-button .md-button--primary download=\"SparkFun_OTOS_XRP_Visualization.zip\" }  <p></p> <p>Visualization Script in Action</p>"},{"location":"single_page/#software-setup-first-tech-challenge-java","title":"Software Setup - FIRST Tech Challenge Java","text":""},{"location":"single_page/#update-the-ftc-robot-controller","title":"Update the FTC Robot Controller","text":"<p>Attention</p> <p>Version v9.2 of the FTC SDK added our Java driver, so it is no longer necessary to manually install those files. Make sure you have at least v9.2 installed on your Control Hub before continuing!</p>"},{"location":"single_page/#hardware-configuration","title":"Hardware Configuration","text":"<p>You can edit your robot's hardware configuration from the Driver Station. Select the I<sup>2</sup>C port that the OTOS is connected to, then tap the \"Add\" button. From the dropdown, you should see \"SparkFun OTOS\" like so:</p> <p></p> <p>Hardware Configuration</p> <p>Warning</p> <p>If you don't see \"SparkFun OTOS\" in the dropdown, make sure you have updated your Control Hub to use at least version v9.2 of the FTC SDK. </p> <p>Then enter a name for the sensor. The sample OpMode assumes it is named <code>sensor_otos</code>, so that is recommended.</p> <p>Once done, save your hardware configuration, then you're ready to run the sample OpMode!</p>"},{"location":"single_page/#troubleshooting-tips","title":"Troubleshooting Tips","text":"<p>A few things we've noticed: </p>"},{"location":"single_page/#calibration","title":"Calibration","text":"<p>Got the spins? If the IMU isn't calibrated correctly, the gyroscope will think the robot is constantly rotating and you may see something like below. If you find this, try re-calibrating your bot. </p> <p></p> <p>Example of Calibration Error</p> <p>Note</p> <p>  Not working as expected and need help?  </p> <p>If you need technical assistance and more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting. </p> <p>SparkFun Technical Assistance Page</p> <p>If you don't find what you need there, the SparkFun Forums are a great place to find and ask for help. If this is your first visit, you'll need to create a Forum Account to search product forums and post questions.</p> <p>Create New Forum Account Log Into SparkFun Forums</p>"},{"location":"single_page/#resources","title":"Resources:","text":"<p>For more resources related to the SparkFun SparkFun Optical Tracking Odometry Sensor, check out the links listed here: </p> <ul> <li>Product Page</li> <li>Schematic (PDF)</li> <li>Eagle Files (ZIP)</li> <li>Board Dimensions(PNG)</li> <li>Hardware GitHub Repository</li> <li>Optical Tracking Odometry Sensor Register Map (PDF)</li> </ul> <p>Libraries/Packages: </p> <ul> <li>Arduino Library GitHub Repository</li> <li>SparkFun Optical Tracking Odometry Sensor Python Package GitHub</li> <li>SparkFun Optical Tracking Odometry Sensor Java Library GitHub</li> </ul> <p>Visualization Python Script: </p> <ul> <li>XRP Visualization Script</li> </ul> <p>XRP Resources:</p> <ul> <li>XRP 3D Printed Mount on Printables</li> <li>XRP Info Page</li> </ul> <p>First Tech Challenge Resources: </p> <ul> <li>FTC mounts on Onshape </li> <li>Instructions for FTC mounts</li> </ul> <p>Datasheets: </p> <ul> <li>Optical Tracking Sensor - PAA5160 Datasheet</li> <li>6-DoF IMU - LSM6DSO Datasheet</li> <li>Microcontroller - STM32C0 Datasheet</li> </ul>"},{"location":"software_setup-Arduino/","title":"Arduino","text":"<p>Attention</p> <p>If this is your first time using Arduino, please review our tutorial on installing the Arduino IDE. If you have not previously installed an Arduino library, please check out our installation guide.</p> <p>We've written a library to get you started with the SparkFun Optical Tracking Odometry Sensor. You can obtain this library through the Arduino Library Manager by searching for \"Odometry\" and installing the latest version from SparkFun. If you prefer downloading libraries manually, you can grab them from the GitHub Repository.</p>      [SparkFun Optical Tracking Odometry Sensor Arduino Library GitHub](https://github.com/sparkfun/SparkFun_Qwiic_OTOS_Arduino_Library/archive/refs/heads/main.zip){ .md-button .md-button--primary }  <p>In addition to the library provided here, we have written a Python script that allows you to visualize the XRP in real time. Download via the button below. </p>      [XRP Visualization Script](assets/SparkFun_OTOS_XRP_Visualization.zip){ .md-button .md-button--primary download=\"SparkFun_OTOS_XRP_Visualization.zip\" }  <p></p> <p>Visualization Script in Action</p>"},{"location":"software_setup-FTC/","title":"FIRST Tech Challenge","text":""},{"location":"software_setup-FTC/#update-the-ftc-robot-controller","title":"Update the FTC Robot Controller","text":"<p>Attention</p> <p>Version v9.2 of the FTC SDK added our Java driver, so it is no longer necessary to manually install those files. Make sure you have at least v9.2 installed on your Control Hub before continuing!</p>"},{"location":"software_setup-FTC/#hardware-configuration","title":"Hardware Configuration","text":"<p>You can edit your robot's hardware configuration from the Driver Station. Select the I<sup>2</sup>C port that the OTOS is connected to, then tap the \"Add\" button. From the dropdown, you should see \"SparkFun OTOS\" like so:</p> <p></p> <p>Hardware Configuration</p> <p>Warning</p> <p>If you don't see \"SparkFun OTOS\" in the dropdown, make sure you have updated your Control Hub to use at least version v9.2 of the FTC SDK. </p> <p>Then enter a name for the sensor. The sample OpMode assumes it is named <code>sensor_otos</code>, so that is recommended.</p> <p>Once done, save your hardware configuration, then you're ready to run the sample OpMode!</p>"},{"location":"software_setup-Python/","title":"Python","text":"<p>Attention</p> <p>If this is your first time working with Python, there are quite a few useful tutorials on getting started. The Python Programming Section of our Getting Started with the Raspberry Pi Tutorial has some good basic information and resources for getting started with Python. </p>"},{"location":"software_setup-Python/#linuxraspberry-pi-variants","title":"Linux/Raspberry Pi Variants","text":"<p>We've written a python package to get you started with the SparkFun Optical Tracking Odometry Sensor. It's been included in the SparkFun Qwiic Python package, which aggregates all Python Qwiic drivers/modules to provide a single entity for Qwiic within a Python environment. The Qwiic_Py GitHub Library ReadMe has more information on the Qwiic Python package. </p> <p>If you already have your Qwiic Python package installed, you can update it with the following command: </p> <pre><code>pip install --upgrade sparkfun-qwiic\n</code></pre> <p>If you don't have the Qwiic Python package installed already, you can install it with the following command: </p> <pre><code>pip install sparkfun-qwiic\n</code></pre> <p>If you prefer to install just this package, use the following command: </p> <pre><code>pip install sparkfun-qwiic-otos\n</code></pre> <p>If you prefer downloading the code to build and install the package manually, you can grab them from the GitHub Repository.</p>      [SparkFun Optical Tracking Odometry Sensor Python Package GitHub](https://github.com/sparkfun/Qwiic_OTOS_Py/archive/refs/heads/master.zip){ .md-button .md-button--primary }  <p>Attention</p> <p>If you are working with a Raspberry Pi and are using the new Bookworm distribution of the Raspberry Pi OS, refer to these instructions to setup a virtual environment.  </p> <p>Make sure to include the --system-site-packages flag:python3 -m venv  --system-site-packages  <p>Then it is possible to install the packages using pip. </p>"},{"location":"software_setup-Python/#xrpmicrocontrollers","title":"XRP/MicroControllers","text":"<p>If you are working with the XRP or other microcontroller, pip will not work for you. Instead, you'll need to install the Qwiic_I2C_Py driver as well as the Qwiic_OTOS driver. </p> <p>Attention</p> <p>These instructions are written for the XRP using the XRPCode IDE. However the setup process is very similar for MicroPython and CircuitPython on any other board, so you should be able to follow along with these instructions using your IDE of choice!</p>"},{"location":"software_setup-Python/#install-qwiic_i2c_py","title":"Install Qwiic_I2C_Py","text":"<p>Qwiic_I2C_Py is a generic I2C driver we have created to work on various platforms (such as MicroPython). Our Qwiic Python device drivers take advantage of Qwiic_I2C_Py to function correctly on any of the supported platforms, so it is a required dependency to use our OTOS Python driver.</p> <p>Fist, go to the Qwiic_I2C_Py repository and download it as a .zip file. Once downloaded, extract the <code>qwiic_i2c</code> folder within.</p> <p>Connect your XRP to your computer over USB, navigate to the XRPCode IDE, and connect to your XRP. For usage information, see the XRPCode User Guide.</p> <p>Create a new folder within the <code>lib</code> directory (right-click on the folder), and name it <code>qwiic_i2c</code>.</p> <p></p> <p>Create a new folder in the <code>lib</code> directory</p> <p></p> <p>Name the folder <code>qwiic_i2c</code></p> <p>Upload the files from the previously extracted <code>qwiic_i2c</code> folder into the new folder you just created on the XRP. From the File menu, choose the Upload to XRP option: </p> <p></p> <p>Choose the \"Upload to XRP\" option</p> <p>Then select the extracted files: </p> <p></p> <p>Select the extracted I2C Files</p> <p>Then choose the newly created <code>qwiic_i2c</code> folder on the XRP:</p> <p></p> <p>Choose the newly created <code>qwiic_i2c</code> folder</p> <p>Uploading...</p> <p></p> <p>Update in Progress</p> <p>You can test to confirm correct installation by typing <code>import qwiic_i2c</code> followed by <code>qwiic_i2c.get_i2c_driver().scan()</code> in the Shell. If no errors are printed, then the Qwiic_I2C_Py driver has been installed correctly!</p> <p></p> <p>Testing the install</p>"},{"location":"software_setup-Python/#install-qwiic_otos_py","title":"Install Qwiic_OTOS_Py","text":"<p>Fist, go to the Qwiic_OTOS_Py repository and download just the <code>qwiic_otos.py</code> file.</p> <p>Connect your XRP to your computer over USB, navigate to the XRPCode editor, and connect to your XRP. For usage information, see the XRPCode User Guide.</p> <p>Upload the <code>qwiic_otos.py</code> file into the <code>lib</code> folder on the XRP. From the File menu, choose the Upload to XRP option: </p> <p></p> <p>Select the \"Upload to XRP\" Option from the File Menu</p> <p>Select the qwiic_otos.py file: </p> <p></p> <p>Select the qwiic_otos.py file</p> <p>Then select the lib folder on the XRP:</p> <p></p> <p>Select the lib folder on the XRP</p> <p>Updating... </p> <p></p> <p>Updating</p> <p>You can test to confirm correct installation by typing <code>import qwiic_otos</code> followed by <code>qwiic_otos.QwiicOTOS().is_connected()</code> in the Shell. If no errors are printed, then the Qwiic_OTOS_Py driver has been installed correctly!</p> <p>Testing the install:</p> <p></p> <p>Testing the install</p>"},{"location":"software_setup-Python/#visualization","title":"Visualization","text":"<p>In addition to the package provided here, we have written a Python script that allows you to visualize the XRP in real time. Download via the button below. </p>      [XRP Visualization Script](assets/SparkFun_OTOS_XRP_Visualization.zip){ .md-button .md-button--primary download=\"SparkFun_OTOS_XRP_Visualization.zip\" }  <p></p> <p>Visualization Script in Action</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>A few things we've noticed: </p>"},{"location":"troubleshooting/#calibration","title":"Calibration","text":"<p>Got the spins? If the IMU isn't calibrated correctly, the gyroscope will think the robot is constantly rotating and you may see something like below. If you find this, try re-calibrating your bot. </p> <p></p> <p>Example of Calibration Error</p> <p>Note</p> <p>  Not working as expected and need help?  </p> <p>If you need technical assistance and more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting. </p> <p>SparkFun Technical Assistance Page</p> <p>If you don't find what you need there, the SparkFun Forums are a great place to find and ask for help. If this is your first visit, you'll need to create a Forum Account to search product forums and post questions.</p> <p>Create New Forum Account Log Into SparkFun Forums</p>"},{"location":"github/contribute/","title":"Contribute: Make an Augmentation!","text":"<p>Spot an improvement opportunity? Feel free to contribute to our open-source design and documentation. </p>"},{"location":"github/contribute/#improve-our-documentation","title":"Improve our Documentation","text":"<p>All of this documentation can be modified by you! Please help us make it better.</p> <ul> <li>These pages are contained in the <code>docs</code> folder of the SparkFun Optical Tracking Odometry Sensor repository.</li> </ul>"},{"location":"github/contribute/#submit-a-correction","title":"Submit a Correction","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your corrections or improvements to the markdown file.</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvements to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"github/contribute/#improve-our-hardware-design","title":"Improve our Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun Optical Tracking Odometry Sensor repository.</li> </ul>"},{"location":"github/contribute/#submit-a-design-enhancement","title":"Submit a Design Enhancement","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your design augmentation(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ol> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvement(s) to verify that they are within our board design standards and meet our product design requirements.</li> <li> <p>If approved, we will flag these changes for our next board revision. Congrats! \ud83c\udf7b</p> <p>Info</p> <p>Even if your suggestion is accepted, these changes may not be immediately available for purchase. We may have to cycle through our current product inventory first.</p> </li> </ol> </li> </ol>"},{"location":"github/contribute/#contributors","title":"Contributors","text":"<p>Let's provide some recognition to the contributors for this project!</p> <p> </p>"},{"location":"github/file_issue/","title":"Did we make a mistake?","text":"<p>Spot something wrong? Please let us know. </p> <p>Need Help?</p> <p>If you need technical assistance or more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting. This Submit Issues page is not where users should seek assistance.</p> <p> SparkFun Technical Assistance Page </p> <p>If you can't find what you need there, the SparkFun Forums is a great place to search the product forums and ask questions.</p> <p>Account Registration Required</p> <p>For your first visit to our forum, you'll need to create a Forum Account to post questions.</p>"},{"location":"github/file_issue/#discrepancies-in-the-documentation","title":"Discrepancies in the Documentation","text":"<p>All of our documentation can be modified by you! Please help us make it better.</p> <ul> <li>The documentation files for these pages are contained in the <code>docs</code> folder of the SparkFun Optical Tracking Odometry Sensor repository.</li> </ul>"},{"location":"github/file_issue/#spot-something-wrong","title":"\ud83d\udd0d Spot something wrong?","text":"<p>If a section of the documentation is incorrect, please open an issue and let us know.</p>"},{"location":"github/file_issue/#do-you-have-a-suggested-correction","title":"Do you have a suggested correction?","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your correction(s) or improvement(s) to the markdown file(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvement(s) to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"github/file_issue/#problems-in-the-hardware-design","title":"Problems in the Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun Optical Tracking Odometry Sensor repository.</li> </ul>"},{"location":"github/file_issue/#does-something-not-make-sense","title":"Does something not make sense? \ud83e\udd14","text":"<p>If part of the design is confusing, please open an issue and let us know.</p>"},{"location":"github/file_issue/#did-we-forget-to-include-an-important-function-of-the-board","title":"Did we forget to include an important function of the board? \ud83e\udd26","text":"<p>If part of the board's functionality is missing, please open an issue and file a feature request.</p> <p>Design Considerations</p> <p>Please keep in mind that we may intentionally exclude certain functions of the board to meet our product design requirements.</p> <ul> <li>For example, our Qwiic Micro boards are intended to fit on a small board layout and only use I<sup>2</sup>C communication; therefore, we may not have the SPI and interrupt pins available for users.</li> </ul>"},{"location":"github/file_issue/#do-you-wish-to-contribute-directly-to-improving-the-board-design","title":"Do you wish to contribute directly to improving the board design?","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your design augmentation(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ol> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvement(s) to verify that they are within our board design standards and meet our product design requirements.</li> <li> <p>If approved, we will flag these changes for our next board revision. Congrats! \ud83c\udf7b</p> <p>Info</p> <p>Even if your suggestion is accepted, these changes may not be immediately available for purchase. We may have to cycle through our current product inventory first.</p> </li> </ol> </li> </ol>"}]}